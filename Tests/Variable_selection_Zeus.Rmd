---
title: "Variable selection Zeus"
author: "Anatole Bourrelier"
date: "08/07/2019"
output:
  html_document:
    toc: true
    theme: united
  pdf_document:
    toc: true
    theme: united
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
# "C:/Users/peltier_car/Documents/Bin"
# setwd(getwd()) 
setwd("C:/Users/peltier_car/Documents/Bin") 
library(xlsx)
library(cowplot)
library(parallel)
library(sva)
library(VennDiagram)
library(devtools)
library(PMA)
library(MASS)
require(gridExtra)
load_all("RGCCA/.",export_all = TRUE)
```

# 1 - SGCCA.permute vs MultiCCA.permute
The goal here is to compare the results of MultiCCA and sgcca with sparsity contraints selected by MultiCCA.permute and sgcca.permute.

The two permute functions select the constraint parameters by using a permutation scheme. For each candidate tuning parameter, the following is permormed:
1) Repeat the following n times: a) the samples in (X1,...,XK) are randomly permuted to obtain data sets (X1\*,...,XK\*)
                                 b) Sparce multiple CCA is run on the permuted fata sets to get canonical variates (w1\*,...,wk\*)
                                 c) i) for MultiCCA.permute : record t* = sum(i<j)Cor(Xi*wi*,Wj*wj*)
                                    ii) for sgcca.permute : record t* = sum(i<j)Cov(Xi*wi*,Wj*wj*)
2) Sparce CCA is run on the permuted data sets (X1,...,Xk) to obtain canonical variates (w1,...,wk)
3) Record t = sum(i<j)Cor(Xiwi,Xjwj)
4) The resulting p-value is given by  mean(t*>t); that is the fraction of permuted totals that exceed the total on the real data

[from documentation of MultiCCA.permute]



## 1.1 Constraint parameter choice, correlated data set
We build a data set with an internal correlation structure, and with "missing" values to be able to see if the sparsity selection is pertinent.
The default constraint sets are used for both functions. 

The blocks are built in a way that the 25th first components are correlated between blocks, thus we expect them to be selected.
We can see that the sgcca.permute efficiently selects the components, whereas MultiCCA.permute is lost: althrough it selects components among those interesting, it does not choose the rigth tuning parameters and is too restrictive.

```{r, MultiCCA_permute-and-sgcca_permute-comparison, cache=TRUE}
setwd("C:/Users/peltier_car/Documents/Bin") 

sigma = matrix(c(1,0.2,0.8,
                 0.2,1,0.7,
                 0.8,0.7,1),3,3, byrow = TRUE)

X = mvrnorm(50, rep(0,3),Sigma = sigma)

v1 <- matrix(c(rep(.5,25),rep(0,75)),ncol=1)
v2 <- matrix(c(rep(1,25),rep(0,25)),ncol=1)
v3 <- matrix(c(rep(.5,25),rep(0,175)),ncol=1)

c = 0.5

x1 <- X[,1]%*%t(v1) + c*matrix(rnorm(50*100),ncol=100)
x2 <- X[,2]%*%t(v2) + c*matrix(rnorm(50*50),ncol=50)
x3 <- X[,3]%*%t(v3) + c*matrix(rnorm(50*200),ncol=200)

xlist <- lapply(list(x1, x2, x3),scale2)

nperm = 1000

# Selection via PMA package, crit = correlation
perm.cca <- MultiCCA.permute(xlist, type=c("standard"), nperm = nperm, trace = FALSE)
# print(perm.cca)
plot(perm.cca)

out.cca <- MultiCCA(xlist, type=c("standard"), trace = FALSE,
                    penalty=perm.cca$bestpenalties, ncomponents=1, ws=perm.cca$ws.init)

par(mfrow=c(3,1), mar = rep(2,4))
PlotCGH(out.cca$ws[[1]], chrom=rep(1,ncol(x1)))
PlotCGH(out.cca$ws[[2]], chrom=rep(2,ncol(x2)))
PlotCGH(out.cca$ws[[3]], chrom=rep(3,ncol(x3)))
title(main = "MultiCCA.permute", outer = TRUE, line = -2)

# Selection via sgcca, crit = covariance, all blocks connected
C = matrix(c(0,1,1,
             1,0,1,
             1,1,0),3,3)
params= as.matrix(expand.grid(c11 = seq(0.2, 1, len = 3),
                   c12 = seq(0.2, 1, len = 3),
                   c13 = seq(0.2, 1, len = 3)))
perm.sgcca = sgcca.permute.crit(xlist, C = C, nperm = nperm, scheme = "horst", plot = TRUE, tol = 1e-6)

out.sgcca = sgcca(xlist, C = C, c1 = perm.sgcca$bestpenalties, scheme = "horst")
par(mfrow=c(3,1), mar = rep(2,4))
PlotCGH(out.sgcca$a[[1]], chrom=rep(1,ncol(x1)))
PlotCGH(out.sgcca$a[[2]], chrom=rep(2,ncol(x2)))
PlotCGH(out.sgcca$a[[3]], chrom=rep(3,ncol(x3)))
title(main = "SGCCA.permute, C by default", outer = TRUE, line = -2)

# With specific connection matrix
C = matrix(c(0,0,1,
             0,0,1,
             1,1,0),3,3)
params= as.matrix(expand.grid(c11 = seq(0.2, 1, len = 3),
                   c12 = seq(0.2, 1, len = 3),
                   c13 = seq(0.2, 1, len = 3)))
perm.sgcca = sgcca.permute.crit(xlist, C = C, nperm = nperm, scheme = "horst", plot = TRUE, tol = 1e-6)

out.sgcca = sgcca(xlist, C = C, c1 = perm.sgcca$bestpenalties, scheme = "horst")
par(mfrow=c(3,1), mar = rep(2,4))
PlotCGH(out.sgcca$a[[1]], chrom=rep(1,ncol(x1)))
PlotCGH(out.sgcca$a[[2]], chrom=rep(2,ncol(x2)))
PlotCGH(out.sgcca$a[[3]], chrom=rep(3,ncol(x3)))
title(main = "SGCCA.permute, C customized", outer = TRUE, line = -2)

```

## 1.2 Constraint set parameters, MultiCCA exemple
```{r,cache=TRUE,eval = FALSE}
setwd("C:/Users/peltier_car/Documents/Bin") 

u <- matrix(rnorm(50),ncol=1)
v1 <- matrix(c(rep(.5,25),rep(0,75)),ncol=1)
v2 <- matrix(c(rep(1,25),rep(0,25)),ncol=1)
v3 <- matrix(c(rep(.5,25),rep(0,175)),ncol=1)

x1 <- u%*%t(v1) + matrix(rnorm(50*100),ncol=100)
x2 <- u%*%t(v2) + matrix(rnorm(50*50),ncol=50)
x3 <- u%*%t(v3) + matrix(rnorm(50*200),ncol=200)

xlist <- list(x1, x2, x3)
nperm = 10

# Selection via PMA package, crit = correlation
perm.cca <- MultiCCA.permute(xlist, type="standard",nperm = nperm, trace = FALSE)#, "ordered", "standard")
# print(perm.cca)
plot(perm.cca)

out.cca <- MultiCCA(xlist, type=c("standard"), trace = FALSE,
                    penalty=perm.cca$bestpenalties, ncomponents=1, ws=perm.cca$ws.init)
par(mfrow=c(3,1), mar = rep(2,4))
PlotCGH(out.cca$ws[[1]], chrom=rep(1,ncol(x1)))
PlotCGH(out.cca$ws[[2]], chrom=rep(2,ncol(x2)))
PlotCGH(out.cca$ws[[3]], chrom=rep(3,ncol(x3)))
title(main = "MultiCCA.permute", outer = TRUE, line = -2)

# Selection via sgcca, crit = covariance
C = matrix(c(0,1,1,
             1,0,1,
             1,1,0),3,3)
params= as.matrix(expand.grid(c11 = seq(0.2, 1, len = 3),
                   c12 = seq(0.2, 1, len = 3),
                   c13 = seq(0.2, 1, len = 3)))
perm.sgcca = sgcca.permute.crit(xlist, C = C, nperm = nperm, scheme = "horst", plot = TRUE, tol = 1e-6)

out.sgcca = sgcca(xlist, C = C, c1 = perm.sgcca$bestpenalties, scheme = "horst")
par(mfrow=c(3,1), mar = rep(2,4))
PlotCGH(out.sgcca$a[[1]], chrom=rep(1,ncol(x1)))
PlotCGH(out.sgcca$a[[2]], chrom=rep(2,ncol(x2)))
PlotCGH(out.sgcca$a[[3]], chrom=rep(3,ncol(x3)))
title(main = "SGCCA.permute, C by default", outer = TRUE, line = -2)

# With specific connection matrix
C = matrix(c(0,0,1,
             0,0,1,
             1,1,0),3,3)
params= as.matrix(expand.grid(c11 = seq(0.2, 1, len = 3),
                   c12 = seq(0.2, 1, len = 3),
                   c13 = seq(0.2, 1, len = 3)))
perm.sgcca = sgcca.permute.crit(xlist, C = C, nperm = nperm, scheme = "horst", plot = TRUE, tol = 1e-6)

out.sgcca = sgcca(xlist, C = C, c1 = perm.sgcca$bestpenalties, scheme = "horst")
par(mfrow=c(3,1), mar = rep(2,4))
PlotCGH(out.sgcca$a[[1]], chrom=rep(1,ncol(x1)))
PlotCGH(out.sgcca$a[[2]], chrom=rep(2,ncol(x2)))
PlotCGH(out.sgcca$a[[3]], chrom=rep(3,ncol(x3)))
title(main = "SGCCA.permute, C customized", outer = TRUE, line = -2)

```



# 2 -  Zeus data 
## 2.1 - Loading
```{r, data-loading, cache=TRUE}
setwd("C:/Users/peltier_car/Desktop/INSIGHT_OMICS")
merged_data = read.table("Merged_DataMatrix_Memento.txt", header = TRUE,sep = "\t")
lipidomic_data = read.table("Lipidomic_DataMatrix_Memento.txt", header = TRUE, sep = "\t")
atrophy_rel = read.table("atrophy_rel.txt",sep = "\t")
label_atrophy = read.table("label_brain_atrophy.txt")
```

## 2.2 - Preprocessing 
Batch effects are removed using the ComBat package. 
As RGCCA does not deal with missing data yet, we take the intersection of the individuals represented in every blocks for the analysis.
Except for the selection of constraint parameters, the analysis will be done region by region (Basal Forebraion, Hippocampus and Entorhinal cortex)


```{r, preprocessing, include = TRUE, message=FALSE, error=FALSE, warning= FALSE, cache = TRUE, echo = TRUE}
l_global = rgcca.entry(list(merged_data,lipidomic_data,atrophy_rel), outliers = "0040319_JOPI",
                labels = label_atrophy, batch = list("Sex","APOE_e4"))  # On enleve le batch effect liÃ© au sexe ainsi qu'un outlier
l=l_global$Blocks.corr
l_region = list(l_BF = l, l_HP = l, l_EC= l)
for (i in 1:3){
  l_region[[i]][[3]] = as.matrix(l[[3]][,i])
}
```

## 2.3 - SGCCA bootstrap
Here we do a sparce generalized analysis a high number of times on resampled individuals with replacement. The sparsity parameters are selected via sgcca.permute.
Then we plot the most selected variables for each region.


### 2.3.1 - Sparsity parameter selection
```{r, constraint-parameters-selection, cache=TRUE}
setwd("C:/Users/peltier_car/Documents/Bin") 
nperm = 1000
tol = 1e-6
scheme = "factorial"
C = C = matrix(c(0,0,1,
                 0,0,1,
                 1,1,0),3,3)
A = l
perm.sgcca = sgcca.permute.crit(A = A, C = C, nperm = nperm, scheme = scheme, plot = TRUE, tol = tol)

c1 = perm.sgcca$bestpenalties   # Set of constraints chosen
```

### 2.3.2 - Bootstrap
```{r, sgcca_bootstrap, fig.height=30, fig.width=20, cache=TRUE}
bootstrap_SGCCA_sel = list()
bootstrap_SGCCA_count = list()
top = 20
nb_boot = 1000

c1[3] = 1
par(mfrow = c(3,2))
for (i in 1:3){ 
  bootstrap.sgcca.fit = sgcca.bootstrap(A = l_region[[i]], 
                                        nb_boot =nb_boot,
                                        c1 = c1, 
                                        C = C,
                                        scheme = scheme,
                                        top = top,
                                        tol = 1e-6,
                                        plot = FALSE)
  bootstrap_SGCCA_sel[[i]] = bootstrap.sgcca.fit$top_var  # Save the name of the top variables
  bootstrap_SGCCA_count[[i]] = bootstrap.sgcca.fit$count  # Save the counts of each variables for the plot
}




region = c("Basal Forebrain","Hippocampus","Entorhinal Cortex")
Compounds = c("Metabolites","lipids")
g=list()
Stab = list()
for (j in 1:3){
  for (i in 1:2){
    Stab[[i+2*(j-1)]] = data.frame(Variables = names(bootstrap_SGCCA_count[[j]][[i]])[1:top],Count = bootstrap_SGCCA_count[[j]][[i]][1:top]/nb_boot)
    g[[i+2*(j-1)]] = ggplot(Stab[[i+2*(j-1)]], aes(x = reorder(Variables, Count), y = Count))+
      coord_flip() +
      geom_bar(stat = "identity")+
      ggtitle(paste("Top" ,top, Compounds[i],"in",region[j]))+
      xlab("Variables")+
      ylab("Occurences")+
      theme(axis.title=element_text(size=15))+
      theme(axis.title.y=element_blank())+
      theme(plot.title=element_text(size=20))+
      theme(axis.text = element_text(size=15))
  }
}


plot_grid(g[[1]],g[[2]],g[[3]],g[[4]],g[[5]],g[[6]],nrow = 3)

```

## 2.4 - Bootstrap rgcca
Here we also use a resampling with replacement but without sparsity constraints. The aim is to study the weight of the variables to see if some have a consistent impact on the results of the simulations.
We then plot them, with the mean and the bar excluding the extreme values.

```{r, rgcca_bootstrap, cache=TRUE,fig.width=20}
setwd("C:/Users/peltier_car/Documents/Bin") 
bootstrap_RGCCA_sel = list()
bootstrap_RGCCA_CI = list()
bootstrap_RGCCA_CI_sel = list()

tau = rep(1,3)
ncomp = 1
n_iteration = 1000
alpha = 0.02

for (i in 1:3){ 
  fit.rgcca = rgcca(l_region[[i]],
                    C = C,
                    tau =tau,
                    scheme = "factorial",
                    verbose = FALSE,
                    tol = tol,
                    ncomp = ncomp)

  aci.rgcca.fit = aci.rgcca(object = fit.rgcca, 
                            A = l_region[[i]], 
                            B = n_iteration,
                            alpha = alpha,
                            ndim = 1, 
                            verbose = FALSE, 
                            plot = FALSE)
  
  bootstrap_RGCCA_sel[[i]] = lapply(aci.rgcca.fit$CI_sel,rownames)
  bootstrap_RGCCA_CI[[i]] = aci.rgcca.fit$CI
  bootstrap_RGCCA_CI_sel[[i]] = aci.rgcca.fit$CI_sel
}



```


```{r, rgcca-bootstrap-plotting, cache=TRUE,fig.width=25,fig.align = 'center'}
par(cex.axis = 2,mar = c(5,6,3,0))
J = 2

for (j in 1:3){
  for (i in 1:2){
print(rownames(bootstrap_RGCCA_CI[[j]][[i]])[which(p.adjust(bootstrap_RGCCA_CI[[j]][[i]][,4], method = "bonferroni")[bootstrap_RGCCA_sel[[j]][[i]]] < 0.05)])
  }
}

for (j in 1:3){
  for (i in 1:2){
    color = rep("green3", nrow(bootstrap_RGCCA_CI[[j]][[i]]))
    Sel     = barplot(bootstrap_RGCCA_CI_sel[[j]][[i]][, 1], col = color, 
                      ylim = c(min(0, min(bootstrap_RGCCA_CI_sel[[j]][[i]][, 2])), max(0, bootstrap_RGCCA_CI_sel[[j]][[i]][, 3])),
                      las = 1,  omi = c(50, 4, 4, 4))
    segments(Sel, bootstrap_RGCCA_CI_sel[[j]][[i]][, 2], Sel, bootstrap_RGCCA_CI_sel[[j]][[i]][, 3])
    segments(Sel-0.1, bootstrap_RGCCA_CI_sel[[j]][[i]][, 2], Sel+0.1, bootstrap_RGCCA_CI_sel[[j]][[i]][, 2])
    segments(Sel-0.1, bootstrap_RGCCA_CI_sel[[j]][[i]][, 3], Sel+0.1, bootstrap_RGCCA_CI_sel[[j]][[i]][, 3])
    title(main = paste("Selected", Compounds[i],"in",region[j]),cex.main = 3)
  }
}
```

# 3 - Methods comparison
## 3.1 Common compounds by method and regions
Here we compare the compounds selected by each method. 
Then we take the intersections by regions and see how they differ from one to the other.
```{r, fig.width=8,fig.heigth = 100,cache=TRUE}
names_M = list()
names_L = list()
for (j in 1:3){
  # print(intersect(bootstrap_SGCCA_sel[[j]][[1]],bootstrap_RGCCA_sel[[j]][[1]]))
  names_M[[j]] = intersect(bootstrap_SGCCA_sel[[j]][[1]],bootstrap_RGCCA_sel[[j]][[1]])
  # print(intersect(bootstrap_SGCCA_sel[[j]][[2]],bootstrap_RGCCA_sel[[j]][[2]]))
  names_L[[j]] = intersect(bootstrap_SGCCA_sel[[j]][[2]],bootstrap_RGCCA_sel[[j]][[2]])
}

venn.plot = list()
region = c("Basal Forebrain","Hippocampus","Entorhinal Cortex")
Compounds = c("Metabolites","lipids")
labels = rep(0,6)
for (j in 1:3){
  for (i in 1:2){
  venn.plot[[i+2*(j-1)]] <- draw.pairwise.venn(
    area1 = length(bootstrap_SGCCA_sel[[j]][[i]]),    area2 = length(bootstrap_RGCCA_sel[[j]][[i]]),
    cross.area = length(intersect(bootstrap_SGCCA_sel[[j]][[i]],bootstrap_RGCCA_sel[[j]][[i]])),
    category = c(paste("SGCCA top \n", top), "RGCCA"),
    cat.pos = c(300, 0),
    euler.d = TRUE,
    sep.dist = 0.03,
    cex = 1.5,
    cat.dist = c(0.05, 0.05),
    rotation.degree = 25,
    ind = FALSE
  )
  labels[i+2*(j-1)] = paste("Comparison selected",Compounds[i],"\n in",region[j])
  }
}

v = lapply(venn.plot,grobTree)
plot_grid(v[[1]],v[[2]],v[[3]],v[[4]],v[[5]],v[[6]],labels = labels,scale = 0.8,label_size = 10, hjust = 0,nrow = 3,vjust = 0.95)

```

```{r, fig.width=20, fig.height=15, cache=TRUE}

venn.plot_M = draw.triple.venn(
  area1 = length(names_M[[1]]),
  area2 = length(names_M[[2]]),
  area3 = length(names_M[[3]]),
  n12 = length(intersect(names_M[[1]],names_M[[2]])),
  n23 = length(intersect(names_M[[2]],names_M[[3]])),
  n13 = length(intersect(names_M[[1]],names_M[[3]])),
  n123 = length(intersect(intersect(names_M[[1]],names_M[[2]]),names_M[[3]])),
  category = c("Basal Forebrain", "Hippocampus", "Entorhinal Cortex"),
  fill = c("skyblue", "tomato", "limegreen"),
  lty = c(3,1,5),
  cex = 3,      
  cat.cex = 4,
  margin = .05,
  cat.dist = c(0.06, 0.06, 0.06),
  cat.pos = c(300,60,180),
  ind = FALSE
)


venn.plot_L = draw.triple.venn(
  area1 = length(names_L[[1]]),
  area2 = length(names_L[[2]]),
  area3 = length(names_L[[3]]),
  n12 = length(intersect(names_L[[1]],names_L[[2]])),
  n23 = length(intersect(names_L[[2]],names_L[[3]])),
  n13 = length(intersect(names_L[[1]],names_L[[3]])),
  n123 = length(intersect(intersect(names_L[[1]],names_L[[2]]),names_L[[3]])),
  category = c("Basal Forebrain", "Hippocampus", "Entorhinal Cortex"),
  fill = c("skyblue", "tomato", "limegreen"),
  lty = c(3,1,5),
  cex = 3,      
  cat.cex = 4,
  margin = .05,
  cat.dist = c(0.02, 0.05, 0.05),
  cat.pos = c(300,60,180),
  ind = FALSE)



plot_grid(grobTree(venn.plot_M),grobTree(venn.plot_L),labels = c("Selected metabolites","Selected lipids"),vjust = 1,scale = 0.75,label_size = 40)
```

## 3.2 - Link with annotations
The annotations allow a link with the pathways the compounds interact with.
```{r,cache=TRUE}
names_M = list(Basal_Forebrain = NULL,Hippocampus = NULL, Entorhinal_Cortex = NULL)
names_L = list(Basal_Forebrain = NULL,Hippocampus = NULL, Entorhinal_Cortex = NULL)
for (j in 1:3){
  # print(intersect(bootstrap_SGCCA_sel[[j]][[1]],bootstrap_RGCCA_sel[[j]][[1]]))
  names_M[[j]] = intersect(bootstrap_SGCCA_sel[[j]][[1]],bootstrap_RGCCA_sel[[j]][[1]])
  # print(intersect(bootstrap_SGCCA_sel[[j]][[2]],bootstrap_RGCCA_sel[[j]][[2]]))
  names_L[[j]] = intersect(bootstrap_SGCCA_sel[[j]][[2]],bootstrap_RGCCA_sel[[j]][[2]])
}


setwd("C:/Users/peltier_car/Desktop/INSIGHT_OMICS")
Annot_merged = read.xlsx("Data_CS_whole_samples/Merged_Annot.xlsx", sheetIndex = 1)
Annot_lipido = read.xlsx("Data_CS_whole_samples/Lipido_Annot.xlsx", sheetIndex = 1)

rownames(Annot_merged) = Annot_merged[,1]
rownames(Annot_lipido) = Annot_lipido[,13]

lapply(names_M, function(x) Annot_merged[x,c("mz", "ID_Annot")])
lapply(names_L, function(x) Annot_lipido[x,c("mzmed","NOT_class")])

```