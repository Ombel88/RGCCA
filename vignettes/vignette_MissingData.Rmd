---
title: "Dealing with missing values in RGCCA package"
date: '`r Sys.Date()`'
output: 
  pdf_document:
   number_sections: yes
   toc: yes
   fig_height: 6
   fig_width: 6
vignette: >
  %\VignetteIndexEntry{Dealing with missing values in RGCCA package} 
  %\VignetteEngine{knitr::rmarkdown}
  \usepackage[utf8]{inputenc}
header-includes:
- \usepackage{amsfonts}
- \usepackage{algorithm2e}
- \usepackage{times}
- \usepackage{bm}
- \usepackage{soul}
- \usepackage{epsfig}
- \usepackage{amssymb}
- \usepackage{natbib}
- \usepackage{lscape}
- \usepackage{graphicx}
- \usepackage{tikz}
- \usetikzlibrary{arrows}
- \usepackage{amsmath}
- \usepackage{color}
- \usepackage{float}
- \usepackage{amsfonts}
- \usepackage{latexsym}
- \usepackage{graphicx,psfrag,color}
- \usepackage{amsmath,amssymb}
- \usepackage{multirow}
- \usepackage{amsthm}
- \usepackage{enumerate}
- \usepackage{enumitem}
- \usepackage{setspace}
- \usepackage{subfigure}
- \usepackage{longtable}
- \usepackage{etoolbox}
- \usepackage{pdfpages}
- \usepackage[mathscr]{euscript}
- \usepackage[T1]{fontenc}
- \usepackage[english]{babel}
- \usepackage[misc]{ifsym}
- \usepackage{wasysym}
- \usepackage{hyperref}
- \usepackage{breakurl}
- \usepackage{pgfplots}
- \usepackage{microtype}
bibliography: biblio.bib
---

\newcommand{\ma}[1]{\ensuremath{\mathbf{#1}}}
\newcommand{\sign}{\ensuremath{\mathrm{sign}}}
\newcommand{\cov}{\ensuremath{\text{cov}}}
\newcommand{\X}{\mathbf{X}}
\newcommand{\A}{\mathbf{A}}
\newcommand{\Q}{\mathbf{Q}}
\newcommand{\M}{\mathbf{M}}
\newcommand{\mbc}{\mathbf{c}}
\newcommand{\I}{\mathbf{I}}
\newcommand{\mbP}{\mathbf{P}}
\newcommand{\mba}{\mathbf{a}}
\newcommand{\z}{\mathbf{z}}
\newcommand{\w}{\mathbf{w}}
\newcommand{\y}{\mathbf{y}}
\newcommand{\mbb}{\mathbf{b}}
\newcommand{\Xu}{\underline{\mathbf{X}}}
\newcommand{\Pu}{\underline{\mathbf{P}}}
\newcommand{\x}{\mathbf{x}}
\newcommand{\K}{\mathbf{K}}
\newcommand{\mcH}{\mathcal{H}}
\newcommand{\bsx}{\boldsymbol{x}}
\newcommand{\bsxi}{\boldsymbol{\xi}}
\newcommand{\bsa}{\boldsymbol{\alpha}}
\newcommand{\mat}[1]{\textbf{\text{#1}}}

\bibliographystyle{apalike}
\bibliography{biblio}


```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{r, echo = FALSE, warning=FALSE, message = FALSE}
library(ggplot2)
library(parallel)
library(vegan)
```


# Introduction
Multidisciplinary approaches are now common in scientific research and provide multiple and heterogeneous sources of measures of a given phenomenon. These sources can be viewed as a collection of interconnected datasets and dedicated algorithms are mandatory for providing relevant information from multi-source data. Regularized Generalized Canonical Correlation Analysis (RGCCA) is a general statistical framework for multi-source data analysis [@Tenenhaus2011]. Multi-source data often have block-wise missing structure, i.e., data in one or more sources may be completely unobserved for a sample. The probability to observe block-wise missing structure increases with the number of sources. It is therefore mandatory to properly handle this block-wise missing structure within the framework of RGCCA.
In literature, many solutions exist to deal with missing data: NIPALS-type algorithms, and imputation methods (simple or multiple). For the moment, these solutions are not applied to integrative analysis. 

In this work, several solutions are investigated and compared on simulations and on multi-source biological data. Furthermore, a methodology for choosing the best NA solution according to the dataset is given.  


# An example dataset: Russett 
```{r}
library(RGCCA)
data(Russett)
head(Russett)
```

The first step of the RGCCA is to define the blocks. Three blocks of variables have been defined for 47 countries. The variables that compose each block have been defined according to the nature of the variables.

- The first block $\X_1$ = [GINI, FARM, RENT] is related to "Agricultural Inequality":
    + GINI = Inequality of land distribution,
    + FARM = \% farmers that own half of the land (> 50),
    + RENT = \% farmers that rent all their land.

- The second block $\X_2$ = [GNPR, LABO] describes "Industrial Development":
    + GNPR = Gross national product per capita ($1955),
    + LABO = % of labor force employed in agriculture.

- The third one $\X_3$ = [INST, ECKS, DEAT] measures "Political Instability":
    + INST = Instability of executive (45-61),
    + ECKS = Number of violent internal war incidents (46-61),
    + DEAT = Number of people killed as a result of civic group violence (50-62).
    + An additional variable DEMO describes the political regime: stable democracy, unstable democracy or dictatorship. The dummy variable "unstable democracy" has been left out because of redundancy.

The different blocks of variables $\ma X_1, \ldots, \ma X_J$ are arranged in the list format.

```{r}
X_agric = as.matrix(Russett[,c("gini","farm","rent")])
X_ind = as.matrix(Russett[,c("gnpr","labo")])
X_polit = as.matrix(Russett[ , c("inst", "ecks",  "death")])
A = list(X_agric, X_ind, X_polit)
sapply(A, head)
lapply(A,dim)
```
# Creating and vizualizing dataset with missing values

## Creating a dataset with missing values from a complete dataset
The function createNA transforms a complete dataset into a dataset with missing values. The parameter pNA specifies the probability of missing values around the dataset (pNA is a proportion), by block (if pNA is a vector of length(A)) or by variable (if pNA is a list of length (A)). The minimum number of complete individuals can be specified in the option "nAllRespondants". Two options are available for the missing data: either they are missing by block (option="block") or randomly in the block (option="ponc")
```{r}
res_create=createNA(A,pNA=0.2,seed=41)
names(res_create)
A_missing=res_create$dat
lapply(A_missing,head)
```
createNA return a list containing the data with missing values, the position of missing values and the complete subjects kept in the analysis.

## Vizualizing a dataset with missing values, and getting the pattern of missing values

To visualize a dataset with missing values, the function determine_patternNA can be used. It also return the percent of missing values per variables and per block.
```{r, fig.height = 3, fig.width = 7, fig.align = "center"}
patternNA=determine_patternNA(A=A_missing)
names(patternNA)
```

```{r, fig.height = 3, fig.width = 7, fig.align = "center"}
A_missing2=createNA(A,option="byvar",pNA=list(0.1*1:3,rep(0,2),rep(0.1,3)))$dat
determine_patternNA(A_missing2)

```

# Using complete data only
The complete data approach is the less risky, but can conduct to a large loss of data, potentially leading to less significant results. It is the one used by default in most software solutions. 
```{r}
A_inter=intersection(A_missing)
lapply(A_inter,dim)
```
# Using NIPALS algorithm 

## Principle
This approach is based on NIPALS algorithm and PLS-PM approach, and consists in re-writing the algorithm by ignoring the missing values. Thus, calculating a matricial product without taking into account missing values is equivalent to replace the missing value by zero, regression on missing value removes the observation, and correlations are made pairwise. Thus, contrarily to the complete data approach, all existing data are taken into account during the analysis. 

The resulting RGCCA can be obtained in two method : entering na.rm=TRUE in usual rgcca, or using rgccaNa with the method "rgcca"nipals""

## R Code

```{r}
C=matrix(1,length(A),length(A))-diag(length(A))
rgcca_nipals=rgcca(A=A_missing,C=C,tau=rep(1,length(A)),verbose=FALSE)
rgcca_nipals2=rgccaNa(A=A_missing,C=C,tau=rep(1,length(A)),method="nipals")
names(rgcca_nipals2)
```
# Using k-Nearest Neighbors

We chose here the hotdeck procedure based on the k nearest neighbors. Note that each block $X_j$ is previously centered and scaled. The neighborood notion is based on the euclidean distance between individuals weighted by the number of variables (in order to give the same weight to each block). Thus, the distance between two individuals $i_1$ and $i_2$ can be formalized as: 
$$d(i_1,i_2)=\sum_{j=1}^J\left( \frac{1}{card(P_j)}\sum_{p\in P_j}(\mat{X}_j(i_1,p)-\mat{X}_j(i_2,p))^2\right)$$
$P_j$ being the set of variables where $i_1$ and $i_2$ are not missing.
For each missing value, the distance between the related individual and all the complete individuals are calculated. 


```{r}
rgcca_knnA=rgccaNa(A=A_missing,C=C,tau=rep(1,length(A)),method="knnA")
rgcca_knn3=rgccaNa(A=A_missing,C=C,tau=rep(1,length(A)),method="knn3")
```

## Multiple imputation


Here, we chose the 5-NN. RGCCA is run M (=5) times on the M resulted imputed dataset. 

In order to represent RGCCA, a "reference" representation space must be chosen in order to project all the M results. For example, it can be the space of the RGCCA imputed by the 1-nearest neighbor. We choose here to take the space of the RGCCA of imputation by the average of all individuals weighted by the inverse of their distance with the individual with missing data. 
Regarding the pool of sample plot, procrustean rotation is run for superimpose each of the M RGCCA individual plot on the reference representation space. Thus, each individual correspond to M points. They can be linked by segments or summarized in an ellipse in order to represent the variability due to the estimation of missing data. 
Regarding the pool of variable plot, only the representation variable space is shown in order to not overload the graph.

Regarding the relevant variables, the standard deviation of the correlations between their scores and first and second axis were added.


```{r, fig.height = 5, fig.width = 5, fig.align = "center"}
mi_rgcca=MIRGCCA(A=A_missing,k=3,ni=5,scale=TRUE,sameBlockWeight=TRUE,tau=rep(1,3))
plotMIRGCCA(mi.obj=mi_rgcca,multiple="ell",indnames=FALSE)
```
```{r, fig.height = 5, fig.width = 5, fig.align = "center"}
plotMIRGCCA(mi.obj=mi_rgcca,multiple="seg",indnames=FALSE)

```

# Using Josse-type algorithms

# Which method to use?
Among all these methods for dealing with missing data, we suspect that the best is dataset-depending, and the ideal is to compare the method results to choose the more adapted to the dataset.


## Simulations on complete dataset according to this pattern

To select the more appropriate method for a given dataset, simulations are made on the complete part of the dataset. This is based on the assumptions that the missing values were randomly distributed, and that the complete part is a representative part of the dataset. 

whichNAmethod simulates nDatasets (20 by default) with missing values according to a specific pattern of missing values (patternNA) and options ("block","byvar" or "ponc"). plotWhichNAmethod allows to select one of the following indicators

The idea is to compare the results of the different "missing methods" to the original results (known, as the initial dataset is complete)
\begin{itemize}
\item output="a": distance between the weights of missing and original RGCCA
\item output="rv": rv coefficient for all individuals on the 1-2 map between missing and original RGCCA (complete method can not be run with this option)
\item output="rvComplete": rv coefficient for complete individuals only on the 1-2 map between missing and reference case 
\item output="bm": percentage of similar top ten of variables
\end{itemize}

```{r, fig.height = 6, fig.width = 6, fig.align = "center"}
res=whichNAmethod(A_missing,listMethods=c("knn1","knn2","knn3","knn4","mean"),patternNA=patternNA$pctNAbyBlock,nDatasets = 1)
plotWhichNAmethod(res,output="a",ylim=c(0,1))
```

In this case, the best method for the similarities between weights is 

# Behavior with increasing missing data proportion
```{r, fig.height = 6, fig.width = 6, fig.align = "center"}
listResults=naEvolution(A=A,listMethods=c("complete","nipals","mean"),prctNA=c(0.05,0.1,0.15,0.2,0.25,0.3,0.4),typeNA="ponc",ncomp=rep(1,3),sameBlockWeight=FALSE)
```
```{r, fig.height = 4, fig.width = 6, fig.align = "center"}
plotEvol(listResults,output="a",barType = "stderr")
```


# References

