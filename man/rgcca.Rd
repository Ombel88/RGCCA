% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/rgcca.R
\name{rgcca}
\alias{rgcca}
\title{Regularized (or Sparse) Generalized Canonical Correlation Analysis (R/SGCCA)}
\usage{
rgcca(
  blocks,
  type = "rgcca",
  scale = TRUE,
  scale_block = TRUE,
  connection = matrix(1, length(blocks), length(blocks)) - diag(length(blocks)),
  scheme = "factorial",
  ncomp = rep(1, length(blocks)),
  tau = rep(1, length(blocks)),
  sparsity = rep(1, length(blocks)),
  init = "svd",
  bias = TRUE,
  tol = 1e-08,
  response = NULL,
  superblock = FALSE,
  method = "nipals",
  verbose = FALSE,
  quiet = TRUE,
  knn.k = "all",
  knn.output = "weightedMean",
  knn.klim = NULL,
  knn.scale_block = TRUE
)
}
\arguments{
\item{blocks}{A list that contains the \eqn{J} blocks of variables \eqn{\mathbf{X_1}, \mathbf{X_2}, ..., \mathbf{X_J}}.}

\item{type}{A character giving the type of analysis: c('rgcca', 'cpca-w', 'gcca', 'hpca', 'maxbet-b', 'maxbet', 'maxdiff-b','maxdiff', 'maxvar-a', 'maxvar-b', 'maxvar', 'niles', 'r-maxvar', 'rcon-pca',
'ridge-gca', 'sabscor', 'ssqcor', 'ssqcor', 'ssqcov-1', 'ssqcov-2', 'ssqcov',
'sum-pca', 'sumcor', 'sumcov-1', 'sumcov-2', 'sumcov.', 'sabscov', 'plspm','cca', 'ra', 'ifa', 'pls','pca')}

\item{scale}{If scale = TRUE, each block is standardized to zero means and unit variances (default: TRUE).}

\item{scale_block}{TRUE by default : each block have the same weight in the RGCCA analysis. If FALSE, the weight of each block depends on the number of variables of the block}

\item{connection}{A design matrix that describes the relationships between blocks (default: complete design).}

\item{scheme}{The value is "horst", "factorial", "centroid" or the g function (default: "centroid").}

\item{ncomp}{A \eqn{1 \times J} vector that contains the numbers of components for each block (default: rep(1, length(A)), which gives one component per block.). It can be estimated by using \link{rgcca_permutation}.}

\item{tau}{Used for type="rgcca" only. tau is either a \eqn{1 \times J} vector or a \eqn{\mathrm{max}(ncomp) \times J} matrix, and contains the values 
of the regularization parameters (default: tau = 1, for each block and each dimension).
If tau = "optimal" the regularization paramaters are estimated for each block and each dimension using the Schafer and Strimmer (2005)
analytical formula . If tau is a \eqn{1\times J} numeric vector, tau[j] is identical across the dimensions of block \eqn{\mathbf{X}_j}. 
If tau is a matrix, tau[k, j] is associated with \eqn{\mathbf{X}_{jk}} (\eqn{k}th residual matrix for block \eqn{j})}

\item{sparsity}{Used for type="sgcca" or "spls" only. A vector containing the sparsity coefficients (length J, between 0 and 1). It can be estimated by using \link{rgcca_permutation}.}

\item{init}{The mode of initialization to use in RGCCA algorithm. The alternatives are either by Singular Value Decompostion ("svd") or random ("random") (Default: "svd").}

\item{bias}{A logical value for biaised or unbiaised estimator of the var/cov (default: bias = TRUE).}

\item{tol}{The stopping value for convergence.}

\item{response}{Integer representing the number of the response block. Indeed, when a supervised analysis is chosen (plspm, pls), the response block has to be specified.}

\item{superblock}{A boolean giving the presence (TRUE) / absence (FALSE) of
a superblock}

\item{method}{Either a character corresponding to the used method ("complete","knn","em","sem") or a function taking a list of J blocks (A) as only parameter and returning the imputed list. 
\itemize{
\item{\code{"mean"}}{ corresponds to an imputation by the colmeans}
\item{\code{"complete"}}{ corresponds to run RGCCA only on the complete subjects (subjects with missing data are removed)}
\item{\code{"nipals"}}{ corresponds to run RGCCA on all available data (NIPALS algorithm)}
\item{\code{"em"}}{ corresponds to impute the data with EM-type algorithms}
\item{\code{"sem"}}{ corresponds to impute the data with EM-type algorithms with superblock approach}
\item{\code{"knn1"}}{ corresponds to impute the data with the 1-Nearest Neighbor. 1 can be replace by another number (such as knn3) to impute with the 3-Nearest Neighbors.}}}

\item{verbose}{If verbose = TRUE, the progress will be report while computing (default: TRUE).}

\item{quiet}{If TRUE, does not print warnings}

\item{knn.k}{Used only if missing values in the blocks are estimated by k-NN methods. Number of k nearest neighbors. Can also be "auto" for automatic selection.}

\item{knn.output}{"mean", "random" or "weightedMean" : Used only if missing values in the blocks are estimated by k-NN methods. Returns respectively the average of the k nearest neigbors, one selected randomly, or an average weighted by the distance of the k NN}

\item{knn.klim}{Used only if missing values in the blocks are estimated by k-NN methods, and if knn.k is "auto". k limits (if k is not a number, optimal k between klim[1] and klim[2] is calculated )}

\item{knn.scale_block}{Used only if missing values in the blocks are estimated by k-NN methods.if TRUE the distance for Nearest Neigbors takes the size of blocks into account}
}
\value{
A RGCCA object

\item{Y}{A list of \eqn{J} elements. Each element of \eqn{Y} is a matrix that contains the RGCCA components for the corresponding block.}

\item{a}{A list of \eqn{J} elements. Each element of \eqn{a} is a matrix that contains the outer weight vectors for each block.}

\item{astar}{A list of \eqn{J} elements. Each element of astar is a matrix defined as Y[[j]][, h] = A[[j]]\%*\%astar[[j]][, h].}

\item{tau}{A vector or matrix that contains the values of the shrinkage parameters applied to each block and each dimension (user specified).}

\item{crit}{A vector that contains the values of the criteria across iterations.}

\item{mode}{A \eqn{1 \times J} vector that contains the formulation ("primal" or "dual") applied to each of the \eqn{J} blocks within the RGCCA alogrithm}

\item{AVE}{indicators of model quality based on the Average Variance Explained (AVE): AVE(for one block), AVE(outer model), AVE(inner model).}

\item{A}{ blocks used in the calculations. Imputed block if imputation method were chosen}

\item{call}{Call of the function}
}
\description{
RGCCA is a generalization
of regularized canonical correlation analysis to three or more sets of variables. SGCCA extends RGCCA to address the issue of variable selection
}
\details{
Given \eqn{J} matrices \eqn{\mathbf{X_1}, \mathbf{X_2}, ..., \mathbf{X_J}} that represent 
\eqn{J} sets of variables observed on the same set of \eqn{n} individuals. The matrices 
\eqn{\mathbf{X_1}, \mathbf{X_2}, ..., \mathbf{X_J}} must have the same number of rows, 
but may (and usually will) have different numbers of columns. The aim of RGCCA is to study 
the relationships between these \eqn{J} blocks of variables. It constitutes a general 
framework for many multi-block data analysis methods. It combines the power of 
multi-block data analysis methods (maximization of well identified criteria) 
and the flexibility of PLS path modeling (the researcher decides which blocks 
are connected and which are not). Hence, the use of RGCCA requires the construction 
(user specified) of a design matrix, (\eqn{\mathbf{C}}), that characterize 
the connections between blocks. Elements of the (symmetric) design matrix \eqn{\mathbf{C} = (c_{jk})} 
is equal to 1 if block \eqn{j} and block \eqn{k} are connected, and 0 otherwise.
The objective is to find a fixed point of the stationary equations related to the RGCCA optimization 
problem. The function rgcca() implements a monotonically convergent algorithm (i.e. the bounded
criteria to be maximized increases at each step of the iterative procedure) that is very 
similar to the PLS algorithm proposed by Herman Wold. Moreover, depending on the 
dimensionality of each block \eqn{\mathbf{X}_j}, \eqn{j = 1, \ldots, J}, the primal (when \eqn{n > p_j}) algorithm or 
the dual (when \eqn{n < p_j}) algorithm is used (see Tenenhaus et al. 2013). 
Moreover, by deflation strategy, rgcca() allow to compute several RGCCA block
components (specified by ncomp) for each block. Block components of each block are guaranteed to 
be orthogonal with the use of the deflation. The so-called symmetric deflation is considered in
this implementation, i.e. each block is deflated with respect to its own component.
It should be noted that the numbers of components per block can differ from one block to another. 
SGCCA extends RGCCA to address the issue of variable selection. Specifically, 
RGCCA is combined with an L1-penalty that gives rise to Sparse GCCA (SGCCA) Blocks are not necessarily fully connected
within the SGCCA framework.
The SGCCA algorithm is very similar to the RGCCA algorithm and keeps the same monotone 
convergence properties (i.e. the bounded criteria to be maximized increases 
at each step of the iterative procedure and hits at convergence a stationary point).
Moreover, using a deflation strategy, sgcca() enables the computation of several SGCCA block 
components (specified by ncomp) for each block. Block components for each block are guaranteed to be orthogonal 
when using this deflation strategy. The so-called symmetric deflation is considered in this implementation,
i.e. each block is deflated with respect to its own component. 
Moreover, we stress that the numbers of components per block could differ from one block to another.
}
\examples{
#############
# Example 1 #
#############
data(Russett)
X_agric =as.matrix(Russett[,c("gini","farm","rent")])
X_ind = as.matrix(Russett[,c("gnpr","labo")])
X_polit = as.matrix(Russett[ , c("demostab", "dictator")])
A = list(X_agric, X_ind, X_polit);names(A)=c("Agri","Indus","Polit")
#Define the design matrix (output = C) 
C = matrix(c(0, 0, 1, 0, 0, 1, 1, 1, 0), 3, 3)
result.rgcca = rgcca(A,type="rgcca", connection=C, tau = c(1, 1, 1),superblock=FALSE,
 scheme = "factorial", scale = TRUE)
lab = as.vector(apply(Russett[, 9:11], 1, which.max))
plot(result.rgcca,type="ind",block=1:2,comp=rep(1,2),resp=lab)
############################################
# Example 2: RGCCA and multiple components #
############################################
result.rgcca = rgcca(A,type="rgcca",connection= C, superblock=FALSE,
tau = rep(1, 3), ncomp = c(2, 2, 2),
                     scheme = "factorial", verbose = TRUE)
plot(result.rgcca,resp=lab)
plot(result.rgcca,type="ave")
plot(result.rgcca,type="network")
plot(result.rgcca,type="weight")
############################################
# Example : SGCCA #
############################################
result.sgcca = rgcca(A,type="sgcca",connection= C, superblock=FALSE,
sparsity = rep(0.8, 3), ncomp = c(2, 2, 2),
                     scheme = "factorial", verbose = TRUE)
plot(result.sgcca,resp=lab)
plot(result.sgcca,type="ave")
plot(result.sgcca,type="network")
plot(result.sgcca,type="weight")
}
\references{
Tenenhaus A. and Tenenhaus M., (2011), Regularized Generalized Canonical Correlation Analysis, Psychometrika, Vol. 76, Nr 2, pp 257-284.

Tenenhaus A. et al., (2013), Kernel Generalized Canonical Correlation Analysis, submitted.

Schafer J. and Strimmer K., (2005), A shrinkage approach to large-scale covariance matrix estimation and implications for functional genomics. Statist. Appl. Genet. Mol. Biol. 4:32.
}
\seealso{
\code{\link[RGCCA]{plot.rgcca}}, \code{\link[RGCCA]{print.rgcca}},
\code{\link[RGCCA]{rgcca_crossvalidation}},
\code{\link[RGCCA]{rgcca_permutation}}
\code{\link[RGCCA]{rgcca_predict}}
}
