% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/whichNAmeth.r
\name{whichNAmethod}
\alias{whichNAmethod}
\title{whichNAmethod}
\usage{
whichNAmethod(blocks, listMethods = c("complete", "nipals"),
  typeNA = "block", nDatasets = 20, patternNA = NULL,
  connection = matrix(1, length(blocks), length(blocks)) -
  diag(length(blocks)), tau = rep(1, length(blocks)), ncomp = rep(2,
  length(blocks)), scale_block = TRUE, scale = TRUE, tol = 1e-06,
  verbose = FALSE, scheme = "centroid", seed = NULL,
  typeRGCCA = "rgcca", sparsity = NULL)
}
\arguments{
\item{blocks}{A list that contains the \eqn{J} blocks of variables \eqn{\mathbf{X_1}, \mathbf{X_2}, ..., \mathbf{X_J}}.}

\item{listMethods}{vector containing a list of methods ("mean","complete","nipals"...)
\itemize{
\item{\code{"mean"}}{ corresponds to an imputation by the colmeans}
\item{\code{"complete"}}{ corresponds to run RGCCA only on the complete subjects (subjects with missing data are removed)}
\item{\code{"nipals"}}{ corresponds to run RGCCA on all available data (NIPALS algorithm)}
\item{\code{"em"}}{ corresponds to impute the data with EM-type algorithms}
\item{\code{"sem"}}{ corresponds to impute the data with EM-type algorithms with superblock approach}
\item{\code{"knn1"}}{ corresponds to impute the data with the 1-Nearest Neighbor. 1 can be replace by another number (such as knn3) to impute with the 3-Nearest Neighbors.}}}

\item{typeNA}{structure of missing data required ("ponc" or "block" or "byVar")}

\item{nDatasets}{Number of simulated datasets}

\item{patternNA}{pattern of missing values required. If NULL, result of \link{get_patternNA},else, vector containing the percent of missing data for each block if typeNA="ponc" or "block. If type NA="byVar",list of the same size than blocks. Each element of this list should be a vector whose length is the number of variable in the block, containing for each variable the proportion of missing values.}

\item{connection}{A design matrix that describes the relationships between blocks (default: complete design).}

\item{tau}{Used for type="rgcca" only. tau is either a \eqn{1 \times J} vector or a \eqn{\mathrm{max}(ncomp) \times J} matrix, and contains the values 
of the regularization parameters (default: tau = 1, for each block and each dimension).
If tau = "optimal" the regularization paramaters are estimated for each block and each dimension using the Schafer and Strimmer (2005)
analytical formula . If tau is a \eqn{1\times J} numeric vector, tau[j] is identical across the dimensions of block \eqn{\mathbf{X}_j}. 
If tau is a matrix, tau[k, j] is associated with \eqn{\mathbf{X}_{jk}} (\eqn{k}th residual matrix for block \eqn{j})}

\item{ncomp}{A \eqn{1 \times J} vector that contains the numbers of components for each block (default: rep(1, length(A)), which gives one component per block.). It can be estimated by using \link{rgcca_permutation}.}

\item{scale_block}{TRUE by default : each block have the same weight in the RGCCA analysis. If FALSE, the weight of each block depends on the number of variables of the block}

\item{scale}{If scale = TRUE, each block is standardized to zero means and unit variances (default: TRUE).}

\item{tol}{The stopping value for convergence.}

\item{verbose}{If verbose = TRUE, the progress will be report while computing (default: TRUE).}

\item{scheme}{The value is "horst", "factorial", "centroid" or the g function (default: "centroid").}

\item{seed}{if filled (by a number), the randomness is reproducible.}

\item{typeRGCCA}{type of analysis to be run ("sgcca"or rgcca"...).}

\item{sparsity}{Used for type="sgcca" or "spls" only. A vector containing the sparsity coefficients (length J, between 0 and 1). It can be estimated by using \link{rgcca_permutation}.}
}
\value{
a whichNAmethod object: a list of length nDataset containing. Each element of this list corresponding to each simulated dataset is
a list whose names are the chosen missing methods. Each element of such a list is also a list containing
\itemize{ 
\item{a}{: A vector of size J (number of blocks) corresponding to the norm of difference between the original weight (first axis) and the simulated one for each block }
 \item{rv}{: A vector of size J (number of blocks) corresponding to the rv coefficient between the original individual map (first axis) and the simulated one for each block }
 \item{bm}{: A vector of size J (number of blocks) corresponding to the percent of different top ten variables correlated with first axis and the simulated one for each block}
\item{rvComplete}{: A vector of size J (number of blocks) corresponding to the rv coefficient between the original individual map (first axis) and the simulated one for each block ONLY on the complete individuals}
\item{rmse}{: Available only if imputation. A vector of size J (number of blocks) corresponding to the Root Mean Square Error between the original scores and the simulated ones for each block}
}
}
\description{
Analysis of the comparison of different methods to deal with missing data in RGCCA or SGCCA.
}
\examples{
set.seed(42);X1=matrix(rnorm(350),70,5);X2=matrix(rnorm(280),70,4);
colnames(X1)=paste("blocks",1:5);colnames(X2)=paste("B",1:4);
rownames(X1)=rownames(X2)=paste("S",1:70)
A=list(X1,X2);
res=whichNAmethod(A,listMethods=c("nipals","mean"),patternNA=rep(0.1,2))
}
\seealso{
\link{plot.whichNAmethod}, \link{naEvolution}
}
