% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/whichNAmeth.r
\name{whichNAmethod}
\alias{whichNAmethod}
\title{whichNAmethod}
\usage{
whichNAmethod(
  blocks,
  listMethods = c("complete", "nipals"),
  typeNA = "block",
  nDatasets = 20,
  patternNA = NULL,
  connection = matrix(1, length(blocks), length(blocks)) - diag(length(blocks)),
  tau = rep(1, length(blocks)),
  ncomp = rep(2, length(blocks)),
  scale_block = TRUE,
  scale = TRUE,
  tol = 1e-06,
  verbose = FALSE,
  scheme = "factorial",
  seed = NULL,
  typeRGCCA = "rgcca",
  sparsity = NULL,
  ni = 5
)
}
\arguments{
\item{blocks}{A list of matrices giving the \eqn{J} blocks of variables \eqn{\mathbf{X_1}, \mathbf{X_2}, ..., \mathbf{X_J}}.}

\item{listMethods}{vector containing a list of methods ("mean","complete","nipals"...)
\itemize{
\item{\code{"mean"}}{ corresponds to an imputation by the colmeans}
\item{\code{"complete"}}{ corresponds to run RGCCA only on the complete subjects (subjects with missing data are removed)}
\item{\code{"nipals"}}{ corresponds to run RGCCA on all available data (NIPALS algorithm)}
\item{\code{"em"}}{ corresponds to impute the data with EM-type algorithms}
\item{\code{"sem"}}{ corresponds to impute the data with EM-type algorithms with superblock approach}
\item{\code{"knn1"}}{ corresponds to impute the data with the 1-Nearest Neighbor. 1 can be replace by another number (such as knn3) to impute with the 3-Nearest Neighbors.}}}

\item{typeNA}{structure of missing data required ("ponc" or "block" or "byVar")}

\item{nDatasets}{Number of simulated datasets}

\item{patternNA}{pattern of missing values required. If NULL, result of \link{get_patternNA},else, vector containing the percent of missing data for each block if typeNA="ponc" or "block. If type NA="byVar",list of the same size than blocks. Each element of this list should be a vector whose length is the number of variable in the block, containing for each variable the proportion of missing values.}

\item{connection}{A symmetric matrix (J*J) that describes the relationships 
between blocks. Two values are accepted : '1' for a connection between two 
blocks, or '0' otherwise.}

\item{tau}{Either a 1*J vector or a \eqn{\mathrm{max}(ncomp) \times J} matrix containing the values 
of the regularization parameters (default: tau = 1, for each block and each dimension). Tau varies from 0 (maximizing the correlation) to 1 (maximizing the covariance).
If tau = "optimal" the regularization paramaters are estimated for each block and each dimension using the Schafer and Strimmer (2005)
analytical formula . If tau is a \eqn{1\times J} vector, tau[j] is identical across the dimensions of block \eqn{\mathbf{X}_j}. 
If tau is a matrix, tau[k, j] is associated with \eqn{\mathbf{X}_{jk}} (\eqn{k}th residual matrix for block \eqn{j}). It can be estimated by using \link{rgcca_permutation}.}

\item{ncomp}{A vector of 1*J integers giving the number of component for 
each blocks}

\item{scale_block}{A logical value indicating if each block have the same weight in the RGCCA analysis. Otherwise, the weight of each block depends on the number of variables of the block}

\item{scale}{A logical value indicating if each block is normalised and divided by the square root of its number of variables and then divided by the square root of its number of variables.}

\item{tol}{An integer giving the value for stopping the algorithm convergence.}

\item{verbose}{A logical value indicating if the progress of the analysis will be reported while computing.}

\item{scheme}{A character or a function giving the link function for 
covariance maximization among "horst" (the identity function), "factorial"
 (the squared values), "centroid" (the absolute values). Only, the horst 
 scheme penalizes structural negative correlation. The factorial scheme 
 discriminates more strongly the blocks than the centroid one.}

\item{seed}{if filled (by a number), the randomness is reproducible.}

\item{typeRGCCA}{type of analysis to be run ("sgcca"or rgcca"...).}

\item{sparsity}{Either a \eqn{1*J} vector or a \eqn{max(ncomp) * J} matrix encoding the L1 constraints applied to the outer weight vectors.
Elements of sparsity vary between \eqn{1/sqrt(p_j)} and 1 (larger values of sparsity correspond to less penalization).
If sparsity is a vector, L1-penalties are the same for all the weights corresponding to the same block but different components:
\deqn{for all h, |a_{j,h}|_{L_1} \le c_1[j] \sqrt{p_j},}
with \eqn{p_j} the number of variables of \eqn{X_j}.
If sparsity is a matrix, each row \eqn{h} defines the constraints applied to the weights corresponding to components \eqn{h}:
\deqn{for all h, |a_{j,h}|_{L_1} \le c_1[h,j] \sqrt{p_j}.} It can be estimated by using \link{rgcca_permutation}.}

\item{ni}{number of iteration in em or superblock algorithm}
}
\value{
a whichNAmethod object: a list of length nDataset containing. Each element of this list corresponding to each simulated dataset is
a list whose names are the chosen missing methods. Each element of such a list is also a list containing
\itemize{ 
\item{a}{: A vector of size J (number of blocks) corresponding to the norm of difference between the original weight (first axis) and the simulated one for each block }
 \item{rv}{: A vector of size J (number of blocks) corresponding to the rv coefficient between the original individual map (first axis) and the simulated one for each block }
 \item{bm}{: A vector of size J (number of blocks) corresponding to the percent of different top ten variables correlated with first axis and the simulated one for each block}
\item{rvComplete}{: A vector of size J (number of blocks) corresponding to the rv coefficient between the original individual map (first axis) and the simulated one for each block ONLY on the complete individuals}
\item{rmse}{: Available only if imputation. A vector of size J (number of blocks) corresponding to the Root Mean Square Error between the original scores and the simulated ones for each block}
}
}
\description{
Analysis of the comparison of different methods to deal with missing data in RGCCA or SGCCA.
}
\examples{
set.seed(42);X1=matrix(rnorm(350),70,5);X2=matrix(rnorm(280),70,4);
colnames(X1)=paste("blocks",1:5);colnames(X2)=paste("B",1:4);
rownames(X1)=rownames(X2)=paste("S",1:70)
A=list(X1,X2);
res=whichNAmethod(A,listMethods=c("nipals","mean"),patternNA=rep(0.1,2))
}
\seealso{
\link{plot.whichNAmethod}, \link{naEvolution}
}
