% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/rgccaNa.R
\name{rgccaNa}
\alias{rgccaNa}
\title{Regularized Generalized Canonical Correlation Analysis (RGCCA)}
\usage{
rgccaNa(A, method, C = 1 - diag(length(A)), tau = rep(1, length(A)),
  ncomp = rep(1, length(A)), scheme = "centroid", scale = TRUE,
  init = "svd", bias = TRUE, tol = 1e-08, verbose = TRUE,
  sameBlockWeight = TRUE, knn.k = "all",
  knn.output = "weightedMean", knn.klim = NULL,
  knn.sameBlockWeight = TRUE, pca.ncp = 1)
}
\arguments{
\item{A}{A list that contains the \eqn{J} blocks of variables \eqn{\mathbf{X_1}, \mathbf{X_2}, ..., \mathbf{X_J}}.}

\item{method}{Either a character corresponding to the used method ("complete","knn","em","sem") or a function taking a list of J blocks (A) as only parameter and returning the imputed list.}

\item{C}{A design matrix that describes the relationships between blocks (default: complete design).}

\item{tau}{tau is either a \eqn{1 \times J} vector or a \eqn{\mathrm{max}(ncomp) \times J} matrix, and contains the values 
of the shrinkage parameters (default: tau = 1, for each block and each dimension).
If tau = "optimal" the shrinkage paramaters are estimated for each block and each dimension using the Schafer and Strimmer (2005)
analytical formula . If tau is a \eqn{1\times J} numeric vector, tau[j] is identical across the dimensions of block \eqn{\mathbf{X}_j}. 
If tau is a matrix, tau[k, j] is associated with \eqn{\mathbf{X}_{jk}} (\eqn{k}th residual matrix for block \eqn{j})}

\item{ncomp}{A \eqn{1 \times J} vector that contains the numbers of components for each block (default: rep(1, length(A)), which gives one component per block.)}

\item{scheme}{The value is "horst", "factorial", "centroid" or the g function (default: "centroid").}

\item{scale}{If scale = TRUE, each block is standardized to zero means and unit variances (default: TRUE).}

\item{init}{The mode of initialization to use in RGCCA algorithm. The alternatives are either by Singular Value Decompostion ("svd") or random ("random") (Default: "svd").}

\item{bias}{A logical value for biaised or unbiaised estimator of the var/cov (default: bias = TRUE).}

\item{tol}{The stopping value for convergence.}

\item{verbose}{If verbose = TRUE, the progress will be report while computing (default: TRUE).}

\item{sameBlockWeight}{TRUE by default : each block have the same weight in the RGCCA analysis. If FALSE, the weight of each block depends on the number of variables of the block}

\item{knn.k}{Number of k nearest neighbors}

\item{knn.output}{"mean", "random" or "weightedMean" : returns respectively the average of the k nearest neigbors, one selected randomly, or an average weighted by the distance of the k NN}

\item{knn.klim}{k limits (if k is not a number, optimal k between klim[1] and klim[2] is calculated )}

\item{knn.sameBlockWeight}{if TRUE the distance for Nearest Neigbors takes the size of blocks into account}

\item{pca.ncp}{Number of components chosen in PCA}
}
\value{
\item{Y}{A list of \eqn{J} elements. Each element of \eqn{Y} is a matrix that contains the RGCCA components for the corresponding block.}

\item{a}{A list of \eqn{J} elements. Each element of \eqn{a} is a matrix that contains the outer weight vectors for each block.}

\item{astar}{A list of \eqn{J} elements. Each element of astar is a matrix defined as Y[[j]][, h] = A[[j]]\%*\%astar[[j]][, h].}

\item{C}{A design matrix that describes the relation between blocks (user specified).}

\item{tau}{A vector or matrix that contains the values of the shrinkage parameters applied to each block and each dimension (user specified).}

\item{scheme}{The scheme chosen by the user (user specified).}

\item{ncomp}{A \eqn{1 \times J} vector that contains the numbers of components for each block (user specified).}

\item{crit}{A vector that contains the values of the criteria across iterations.}

\item{mode}{A \eqn{1 \times J} vector that contains the formulation ("primal" or "dual") applied to each of the \eqn{J} blocks within the RGCCA alogrithm}

\item{AVE}{indicators of model quality based on the Average Variance Explained (AVE): AVE(for one block), AVE(outer model), AVE(inner model).}
}
\description{
imputeRGCCA allows to choose the imputation method before running RGCCA
}
\examples{
data(Russett)
X_agric =as.matrix(Russett[,c("gini","farm","rent")])
X_ind = as.matrix(Russett[,c("gnpr","labo")])
X_polit = as.matrix(Russett[ , c("demostab", "dictator")])
X_agric[c(2,4),]=NA
X_ind[1,]=NA
X_polit[5,1]=NA
A = list(agri=X_agric, ind=X_ind, polit=X_polit)
rgccaNa(A,method="nipals")
rgccaNa(A,method="knn2")
}
\references{
Tenenhaus A. and Tenenhaus M., (2011), Regularized Generalized Canonical Correlation Analysis, Psychometrika, Vol. 76, Nr 2, pp 257-284.

Tenenhaus A. et al., (2013), Kernel Generalized Canonical Correlation Analysis, submitted.

Schafer J. and Strimmer K., (2005), A shrinkage approach to large-scale covariance matrix estimation and implications for functional genomics. Statist. Appl. Genet. Mol. Biol. 4:32.
}
