% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/naEvolution.r
\name{naEvolution}
\alias{naEvolution}
\title{Evolution of quality of rgcca with increasing missing values}
\usage{
naEvolution(
  blocks,
  prctNA = c(0.1, 0.2, 0.3),
  listMethods = c("mean"),
  typeNA = "block",
  ncomp = rep(1, length(blocks)),
  scale_block = TRUE,
  scale = TRUE,
  nDatasets = 20,
  tol = 1e-06,
  verbose = FALSE,
  scheme = "centroid",
  seed = NULL,
  connection = matrix(1, length(blocks), length(blocks)) - diag(length(blocks)),
  tau = rep(1, length(blocks))
)
}
\arguments{
\item{blocks}{A list that contains the \eqn{J} blocks of variables \eqn{\mathbf{X_1}, \mathbf{X_2}, ..., \mathbf{X_J}}.}

\item{prctNA}{if number, percentage of missing data required for each block. If a vector with the same size as blocks, the percentage can be adapted for each block. If a list of values, this percent is calculated per variable}

\item{listMethods}{vector containing a list of methods ("mean","complete","nipals"...)
\itemize{
\item{\code{"mean"}}{ corresponds to an imputation by the colmeans}
\item{\code{"complete"}}{ corresponds to run RGCCA only on the complete subjects (subjects with missing data are removed)}
\item{\code{"nipals"}}{ corresponds to run RGCCA on all available data (NIPALS algorithm)}
\item{\code{"em"}}{ corresponds to impute the data with EM-type algorithms}
\item{\code{"sem"}}{ corresponds to impute the data with EM-type algorithms with superblock approach}
\item{\code{"knn1"}}{ corresponds to impute the data with the 1-Nearest Neighbor. 1 can be replace by another number (such as knn3) to impute with the 3-Nearest Neighbors.}}}

\item{typeNA}{structure of missing data required ("ponc" or "block" or "byVar")}

\item{ncomp}{A \eqn{1 \times J} vector that contains the numbers of components for each block (default: rep(1, length(A)), which gives one component per block.). It can be estimated by using \link{rgcca_permutation}.}

\item{scale_block}{TRUE by default : each block have the same weight in the RGCCA analysis. If FALSE, the weight of each block depends on the number of variables of the block}

\item{scale}{If scale = TRUE, each block is standardized to zero means and unit variances (default: TRUE).}

\item{nDatasets}{Number of simulated datasets}

\item{tol}{The stopping value for convergence.}

\item{verbose}{If verbose = TRUE, the progress will be report while computing (default: TRUE).}

\item{scheme}{The value is "horst", "factorial", "centroid" or the g function (default: "centroid").}

\item{seed}{NULL by default (no reproducibility). A number representing the seed (for reproducibility)}

\item{connection}{A design matrix that describes the relationships between blocks (default: complete design).}

\item{tau}{Used for type="rgcca" only. tau is either a \eqn{1 \times J} vector or a \eqn{\mathrm{max}(ncomp) \times J} matrix, and contains the values 
of the regularization parameters (default: tau = 1, for each block and each dimension).
If tau = "optimal" the regularization paramaters are estimated for each block and each dimension using the Schafer and Strimmer (2005)
analytical formula . If tau is a \eqn{1\times J} numeric vector, tau[j] is identical across the dimensions of block \eqn{\mathbf{X}_j}. 
If tau is a matrix, tau[k, j] is associated with \eqn{\mathbf{X}_{jk}} (\eqn{k}th residual matrix for block \eqn{j})}
}
\value{
resultComparison A list of length pNA. Each element of the list is a result of whichNAmethod (see \link{whichNAmethod})
}
\description{
Analysis of the comparison of different NA methods on RGCCA for increasing percent of missing data in each block
}
\examples{
data(Russett)
library(parallel)
X_agric =as.matrix(Russett[,c("gini","farm","rent")])
X_ind = as.matrix(Russett[,c("gnpr","labo")])
X_polit = as.matrix(Russett[ , c("demostab", "dictator")])
A = list(agri=X_agric, ind=X_ind, polit=X_polit)
#ponctual
listResults=naEvolution(blocks=A,listMethods=c("complete","nipals","mean"),
prctNA=c(0.05,0.1,0.15,0.2,0.25,0.3,0.4),typeNA="ponc",ncomp=rep(1,3),
scale_block=FALSE)
plot(listResults,output="a",bars = "stderr",ylim=c(0,0.2))
}
