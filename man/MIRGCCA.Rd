% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/MIRGCCA.R
\name{MIRGCCA}
\alias{MIRGCCA}
\title{Multiple imputation for RGCCA}
\usage{
MIRGCCA(blocks, option = "knn", type = "rgcca", superblock = TRUE,
  k = 5, ni = 5, scale = TRUE, scale_block = TRUE,
  tau = rep(1:length(A)), klim = NULL, output = "mean",
  scheme = "centroid", tol = 1e-08, connection = NULL,
  ncomp = rep(2, length(A)), naxis = 1)
}
\arguments{
\item{blocks}{A list of matrices giving the \eqn{J} blocks of variables \eqn{\mathbf{X_1}, \mathbf{X_2}, ..., \mathbf{X_J}}.}

\item{option}{"knn" for k Nearest Neigbors or "em" for Expectation Maximization}

\item{type}{A character giving the type of analysis: rgcca, sgcca, pca, 
pls, cca, ifa, ra, cpca-w, gcca, hpca, maxbet-b, maxbet, maxdiff-b,maxdiff,
 maxvar-a, maxvar-b, maxvar, niles, r-maxvar, rcon-pca, ridge-gca, sabscor,
 ssqcor, ssqcor, ssqcov-1, ssqcov-2, ssqcov,  sum-pca, sumcor, sumcov-1, 
 sumcov-2, sumcov, sabscov, plspm}

\item{superblock}{TRUE if the A list should be returned in the output, FALSE ifelse}

\item{k}{Integer representing the number of neighbors or "auto" or "all"}

\item{ni}{number of imputations}

\item{scale}{A logical value indicating if each block is normalised and divided by the square root of its number of variables and then divided by the square root of its number of variables.}

\item{scale_block}{A logical value indicating if each block have the same weight in the RGCCA analysis. Otherwise, the weight of each block depends on the number of variables of the block}

\item{tau}{Either a 1*J vector or a \eqn{\mathrm{max}(ncomp) \times J} matrix containing the values 
of the regularization parameters (default: tau = 1, for each block and each dimension). Tau varies from 0 (maximizing the correlation) to 1 (maximizing the covariance).
If tau = "optimal" the regularization paramaters are estimated for each block and each dimension using the Schafer and Strimmer (2005)
analytical formula . If tau is a \eqn{1\times J} vector, tau[j] is identical across the dimensions of block \eqn{\mathbf{X}_j}. 
If tau is a matrix, tau[k, j] is associated with \eqn{\mathbf{X}_{jk}} (\eqn{k}th residual matrix for block \eqn{j}). It can be estimated by using \link{rgcca_permutation}.}

\item{klim}{TRUE if the A list should be returned in the output, FALSE ifelse}

\item{output}{TRUE if the A list should be returned in the output, FALSE ifelse}

\item{scheme}{A character or a function giving the link function for 
covariance maximization among "horst" (the identity function), "factorial"
 (the squared values), "centroid" (the absolute values). Only, the horst 
 scheme penalizes structural negative correlation. The factorial scheme 
 discriminates more strongly the blocks than the centroid one.}

\item{tol}{An integer giving the value for stopping the algorithm convergence.}

\item{connection}{A symmetric matrix (J*J) that describes the relationships 
between blocks. Two values are accepted : '1' for a connection between two 
blocks, or '0' otherwise.}

\item{ncomp}{A vector of 1*J integers giving the number of component for 
each blocks}

\item{naxis}{number of component to select in the superblock for the estimation of missing data for "em" option}
}
\value{
A list_rgcca object containing
\itemize{\item{rgcca0}{ RGCCA results for the reference dataset}
\item{data}{ list of imputed data obtained}
 \item{rgccaList}{ list of RGCCA obtained}}
}
\description{
This method allows multiple imputation for RGCCA with several options.
}
\examples{
set.seed(42);X1=matrix(rnorm(500),100,5);
set.seed(22);X2=matrix(rnorm(400),100,4);
set.seed(2);X3=matrix(rnorm(700),100,7);
rownames(X1)=rownames(X2)=rownames(X3)=paste("S",1:100,sep="")
colnames(X1)=paste("A",1:5)
colnames(X2)=paste("B",1:4)
colnames(X3)=paste("C",1:7)
X1[1,]=NA
X2[7,1]=NA
 X2[5,1]=NA
 X3[3,1:2]=NA
 A=list(X1,X2,X3)
res=MIRGCCA(A,k=3,ni=5,scale=TRUE,scale_block=TRUE,tau=rep(0,3))
}
\seealso{
\code{\link{plot.list_rgcca}}
}
