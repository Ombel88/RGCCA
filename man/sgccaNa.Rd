% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/sgccaNa.R
\name{sgccaNa}
\alias{sgccaNa}
\title{Regularized Generalized Canonical Correlation Analysis (RGCCA)}
\usage{
sgccaNa(
  blocks,
  method,
  connection = 1 - diag(length(blocks)),
  sparsity = rep(1, length(blocks)),
  ncomp = rep(1, length(blocks)),
  scheme = "centroid",
  scale = TRUE,
  init = "svd",
  bias = TRUE,
  tol = 1e-08,
  verbose = TRUE,
  scale_block = TRUE,
  prescaling = FALSE,
  quiet = FALSE
)
}
\arguments{
\item{blocks}{List of blocks.}

\item{method}{Character string corresponding to the method used for 
handling missing values ("nipals", "complete", "mean"). (default: "nipals").
\itemize{
\item{\code{"mean"}}{corresponds to imputation by the colmeans before 
applying the S/RGCCA algorithm}
\item{\code{"complete"}}{corresponds to perform RGCCA on the fully observed  
observations (observations with missing values are removed)}
\item{\code{"nipals"}}{corresponds to perform RGCCA algorithm on available 
data (NIPALS-type algorithm)}}}

\item{connection}{Symmetric matrix (J*J) that describes the relationships 
between blocks. Elements of the connection matrix must be positive ; but 
usually equal to 1 if block \eqn{j} and block \eqn{k} are connected, and 0 
otherwise.}

\item{sparsity}{Either a \eqn{1*J} vector or a \eqn{max(ncomp) * J} matrix 
encoding the L1 constraints applied to the outer weight vectors. The amount 
of sparsity varies between \eqn{1/sqrt(p_j)} and 1 (larger values of sparsity 
correspond to less penalization). If sparsity is a vector, L1-penalties are 
the same for all the weights corresponding to the same block but different 
components: 
\deqn{for all h, |a_{j,h}|_{L_1} \le c_1[j] \sqrt{p_j},}
with \eqn{p_j} the number of variables of \eqn{X_j}.
If sparsity is a matrix, each row \eqn{h} defines the constraints applied to 
the weights corresponding to components \eqn{h}:
\deqn{for all h, |a_{j,h}|_{L_1} \le c_1[h,j] \sqrt{p_j}.} It can be 
estimated by using \link{rgcca_permutation}.}

\item{ncomp}{Vector of length J indicating the number of block components 
for each block.}

\item{scheme}{Character string or a function giving the scheme function for 
covariance maximization among "horst" (the identity function), "factorial"
 (the squared values), "centroid" (the absolute values). The scheme function 
 can be any continously differentiable convex function and it is possible to 
 design explicitely the sheme function (e.g. function(x) x^4) as argument of 
 rgcca function.  See (Tenenhaus et al, 2017) for details.}

\item{scale}{Logical value indicating if blocks are standardized.}

\item{init}{Character string giving the type of initialization to use in 
the  algorithm. It could be either by Singular Value Decompostion ("svd") 
or by random initialisation ("random") (default: "svd").}

\item{bias}{A logical value for biaised (\eqn{1/n}) or unbiaised 
(\eqn{1/(n-1)}) estimator of the var/cov (default: bias = TRUE).}

\item{tol}{The stopping value for the convergence of the algorithm.}

\item{verbose}{Logical value indicating whether the warnings are displayed.}

\item{scale_block}{Logical value indicating if each block is divided by 
the square root of its number of variables.}

\item{prescaling}{Logical value indicating if the scaling has been done
outside of the function.}

\item{quiet}{Logical value indicating if warning messages are reported.}
}
\value{
\item{Y}{A list of J elements. Each element of Y is a 
matrix that contains the RGCCA block components.}

\item{a}{A list of J elements. Each element of a is a 
matrix that contains the outer weight vectors.}

\item{astar}{A list of J elements. Each element of astar is a 
matrix defined as Y[[j]][, h] = A[[j]]\%*\%astar[[j]][, h].}

\item{C}{A symmetric matrix (J*J) that describes the relationships 
between blocks.}

\item{scheme}{A character string defining the scheme function for 
covariance maximization among "horst" (the identity function), "factorial" 
(the squared values), "centroid" (the absolute values). The scheme argument 
can be a user-defined function (e.g. function(x) x^4) but  have
to be a convex continuously differentiable function (to guaranty the 
convergence properties of the algorithm).}

\item{ncomp}{A 1*J vector giving the number of component for each 
block.}

\item{crit}{A numerical vector that contains for each component the 
values of the RGCCA criteria across iterations.}

\item{mode}{A 1*J vector that contains the formulation 
("primal" or "dual") used for each block.}

\item{AVE}{A list of numerical values giving indicators of model 
quality based on the Average Variance Explained (AVE): AVE(for each block), 
AVE(outer model), AVE(inner model).}
}
\description{
imputeRGCCA allows to choose the imputation method before running RGCCA
}
\examples{
data(Russett)
X_agric =as.matrix(Russett[, c("gini", "farm", "rent")])
X_ind = as.matrix(Russett[, c("gnpr", "labo")])
X_polit = as.matrix(Russett[ , c("demostab", "dictator")])
X_agric[c(2, 4), ] = NA # blockwise missing structure
X_ind[1, ] = NA # Ponctual NA
X_polit[5, 1] = NA
A = list(Agric = X_agric, Ind = X_ind, Polit = X_polit)
rgccaNa(A, method = "nipals")
}
\references{
Tenenhaus A. and Tenenhaus M., (2011), Regularized Generalized 
Canonical Correlation Analysis, Psychometrika, Vol. 76, Nr 2, pp 257-284.

Tenenhaus A., Philippe C., and Frouin V. (2015). Kernel 
Generalized Canonical Correlation Analysis. Computational Statistics and 
Data Analysis, 90, 114-131.

Schafer J. and Strimmer K., (2005), A shrinkage approach to 
large-scale covariance matrix estimation and implications for functional 
genomics. Statistical Applications in Genetics and Molecular Biology 4:32.
}
