% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/rgcca_permutation.R
\name{rgcca_permutation}
\alias{rgcca_permutation}
\title{Tuning RGCCA parameters}
\usage{
rgcca_permutation(blocks, perm.par = "tau", perm.value = NULL,
  nperm = 20, n_cores = parallel::detectCores() - 1, quiet = TRUE,
  type = "rgcca", scale = TRUE, scale_block = TRUE,
  connection = matrix(1, length(blocks), length(blocks)) -
  diag(length(blocks)), scheme = "factorial", ncomp = rep(1,
  length(blocks)), tau = rep(1, length(blocks)), sparsity = rep(1,
  length(blocks)), init = "svd", bias = TRUE, tol = 1e-08,
  response = NULL, superblock = FALSE, method = "nipals",
  rgcca_res = NULL, ...)
}
\arguments{
\item{blocks}{A list of matrix}

\item{perm.par}{"sparsity","tau" or "ncomp".}

\item{perm.value}{If perm.par="sparsity", a matrix, a vector or an integer containing sets of constraint 
variables to be tested, one row by combination. By default, sgcca.permute takes 10 sets between 
min values ($1/sqrt(ncol)$) and 1. If perm.par="ncomp", a matrix, a vector or an integer containing sets of number of 
components, one row by set. By default, sgcca.permute takes as many 
combinations as the maximum number of columns in each block. If perm.par="tau",... #TODO}

\item{nperm}{Number of permutation tested for each set of constraint}

\item{n_cores}{An integer for the number of cores used in parallelization}

\item{quiet}{If TRUE, does not print warnings}

\item{type}{A character giving the type of analysis: c('rgcca', 'cpca-w', 'gcca', 'hpca', 'maxbet-b', 'maxbet', 'maxdiff-b','maxdiff', 'maxvar-a', 'maxvar-b', 'maxvar', 'niles', 'r-maxvar', 'rcon-pca',
'ridge-gca', 'sabscor', 'ssqcor', 'ssqcor', 'ssqcov-1', 'ssqcov-2', 'ssqcov',
'sum-pca', 'sumcor', 'sumcov-1', 'sumcov-2', 'sumcov.', 'sabscov', 'plspm','cca', 'ra', 'ifa', 'pls','pca')}

\item{scale}{If scale = TRUE, each block is standardized to zero means and unit variances (default: TRUE).}

\item{scale_block}{TRUE by default : each block have the same weight in the RGCCA analysis. If FALSE, the weight of each block depends on the number of variables of the block}

\item{connection}{A design matrix that describes the relationships between blocks (default: complete design).}

\item{scheme}{The value is "horst", "factorial", "centroid" or the g function (default: "centroid").}

\item{ncomp}{A \eqn{1 \times J} vector that contains the numbers of components for each block (default: rep(1, length(A)), which gives one component per block.). It can be estimated by using \link{rgcca_permutation}.}

\item{tau}{Used for type="rgcca" only. tau is either a \eqn{1 \times J} vector or a \eqn{\mathrm{max}(ncomp) \times J} matrix, and contains the values 
of the regularization parameters (default: tau = 1, for each block and each dimension).
If tau = "optimal" the regularization paramaters are estimated for each block and each dimension using the Schafer and Strimmer (2005)
analytical formula . If tau is a \eqn{1\times J} numeric vector, tau[j] is identical across the dimensions of block \eqn{\mathbf{X}_j}. 
If tau is a matrix, tau[k, j] is associated with \eqn{\mathbf{X}_{jk}} (\eqn{k}th residual matrix for block \eqn{j})}

\item{sparsity}{Used for type="sgcca" or "spls" only. A vector containing the sparsity coefficients (length J, between 0 and 1). It can be estimated by using \link{rgcca_permutation}.}

\item{init}{The mode of initialization to use in RGCCA algorithm. The alternatives are either by Singular Value Decompostion ("svd") or random ("random") (Default: "svd").}

\item{bias}{A logical value for biaised or unbiaised estimator of the var/cov (default: bias = TRUE).}

\item{tol}{The stopping value for convergence.}

\item{response}{if not NULL, number corresponding to the response block}

\item{superblock}{A boolean giving the presence (TRUE) / absence (FALSE) of
a superblock}

\item{method}{Either a character corresponding to the used method ("complete","knn","em","sem") or a function taking a list of J blocks (A) as only parameter and returning the imputed list. 
\itemize{
\item{\code{"mean"}}{ corresponds to an imputation by the colmeans}
\item{\code{"complete"}}{ corresponds to run RGCCA only on the complete subjects (subjects with missing data are removed)}
\item{\code{"nipals"}}{ corresponds to run RGCCA on all available data (NIPALS algorithm)}
\item{\code{"em"}}{ corresponds to impute the data with EM-type algorithms}
\item{\code{"sem"}}{ corresponds to impute the data with EM-type algorithms with superblock approach}
\item{\code{"knn1"}}{ corresponds to impute the data with the 1-Nearest Neighbor. 1 can be replace by another number (such as knn3) to impute with the 3-Nearest Neighbors.}}}

\item{rgcca_res}{Result of a RGCCA (see  \code{\link[RGCCA]{rgcca}} )}

\item{...}{other RGCCA parameters # TODO}
}
\value{
A object permutation, which is a list containing :

\item{pval}{Pvalue}

\item{zstat}{Statistic Z}

\item{bestpenalties}{Penalties corresponding to the best Z-statistic}

\item{permcrit}{RGCCA criteria obtained with permutation set}

\item{crit}{ RGCCA criterion for the original dataset}
}
\description{
Run through a set of parameters (sparsity or number of selected components) with permutation to select the one maximizing RGCCA criterion 
The sparsity parameter is tuned with only one component per block.
}
\examples{
data("Russett")
A = list(agriculture = Russett[, seq(3)], industry = Russett[, 4:5],
    politic = Russett[, 6:11] )
res = rgcca_permutation(A, nperm = 5, n_cores = 1)
rgcca_permutation(A, perm.par = "sparsity", perm.value = 0.8, nperm = 2,
 n_cores = 1)
rgcca_permutation(A, perm.par = "sparsity", perm.value = c(0.6, 0.75, 0.5), 
nperm = 2, n_cores = 1)
rgcca_permutation(A, perm.par = "sparsity", 
perm.value = matrix(c(0.6, 0.75, 0.5), 3, 3, byrow = TRUE),
 nperm = 2, n_cores = 1)
rgcca_permutation(A, perm.par = "tau", perm.value = 0.8, nperm = 2, 
n_cores = 1)
rgcca_permutation(A, perm.par = "tau", perm.value = c(0.6, 0.75, 0.5),
 nperm = 2, n_cores = 1)
rgcca_permutation(A, perm.par = "tau", perm.value = 
matrix(c(0.6, 0.75, 0.5), 3, 3, byrow = TRUE),  nperm = 2, n_cores = 1)
print(res)
}
