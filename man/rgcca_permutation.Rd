% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/rgcca_permutation.R
\name{rgcca_permutation}
\alias{rgcca_permutation}
\title{Tune the S/RGCCA hyper-parameters by permutation.}
\usage{
rgcca_permutation(
  blocks,
  par_type,
  par_value = NULL,
  par_length = 10,
  n_run = 20,
  n_cores = parallel::detectCores() - 1,
  quiet = TRUE,
  scale = TRUE,
  scale_block = TRUE,
  type = NULL,
  connection = matrix(1, length(blocks), length(blocks)) - diag(length(blocks)),
  scheme = "factorial",
  ncomp = rep(1, length(blocks)),
  tau = rep(1, length(blocks)),
  sparsity = rep(1, length(blocks)),
  init = "svd",
  bias = TRUE,
  tol = 1e-08,
  response = NULL,
  superblock = FALSE,
  method = "nipals",
  rgcca_res = NULL,
  parallelization = NULL
)
}
\arguments{
\item{blocks}{A list of matrices giving the \eqn{J} blocks of variables \eqn{\mathbf{X_1}, \mathbf{X_2}, ..., \mathbf{X_J}}.}

\item{par_type}{A character giving the parameter to tune among "sparsity" or 
"tau".}

\item{par_value}{A matrix (n*p, with p the number of blocks and n the number 
of combinations to be tested), a vector (of p length) or a numeric value 
giving sets of penalties (tau for RGCCA, sparsity for SGCCA) to be tested, 
one row by combination. By default, it takes 10 sets between min values (0
 for RGCCA and $1/sqrt(ncol)$ for SGCCA) and 1.}

\item{par_length}{An integer indicating the number of sets of parameters to 
be tested (if par_value = NULL). The parameters are uniformly distributed.}

\item{n_run}{An integer giving the number of permutation tested for each set 
of constraint}

\item{n_cores}{An integer for the number of cores used in parallelization}

\item{quiet}{A logical value indicating if it should not print warnings}

\item{scale}{A logical value indicating if each block is normalised and divided by the square root of its number of variables and then divided by the square root of its number of variables.}

\item{scale_block}{A logical value indicating if each block have the same weight in the RGCCA analysis. Otherwise, the weight of each block depends on the number of variables of the block}

\item{type}{A character giving the type of analysis: rgcca, sgcca, pca, 
pls, cca, ifa, ra, cpca-w, gcca, hpca, maxbet-b, maxbet, maxdiff-b,maxdiff,
 maxvar-a, maxvar-b, maxvar, niles, r-maxvar, rcon-pca, ridge-gca, sabscor,
 ssqcor, ssqcor, ssqcov-1, ssqcov-2, ssqcov,  sum-pca, sumcor, sumcov-1, 
 sumcov-2, sumcov, sabscov, plspm}

\item{connection}{A symmetric matrix (J*J) that describes the relationships 
between blocks. Two values are accepted : '1' for a connection between two 
blocks, or '0' otherwise.}

\item{scheme}{A character or a function giving the link function for 
covariance maximization among "horst" (the identity function), "factorial"
 (the squared values), "centroid" (the absolute values). Only, the horst 
 scheme penalizes structural negative correlation. The factorial scheme 
 discriminates more strongly the blocks than the centroid one.}

\item{ncomp}{A vector of 1*J integers giving the number of component for 
each blocks}

\item{tau}{Either a 1*J vector or a \eqn{\mathrm{max}(ncomp) \times J} matrix containing the values 
of the regularization parameters (default: tau = 1, for each block and each dimension). Tau varies from 0 (maximizing the correlation) to 1 (maximizing the covariance).
If tau = "optimal" the regularization paramaters are estimated for each block and each dimension using the Schafer and Strimmer (2005)
analytical formula . If tau is a \eqn{1\times J} vector, tau[j] is identical across the dimensions of block \eqn{\mathbf{X}_j}. 
If tau is a matrix, tau[k, j] is associated with \eqn{\mathbf{X}_{jk}} (\eqn{k}th residual matrix for block \eqn{j}). It can be estimated by using \link{rgcca_permutation}.}

\item{sparsity}{Either a \eqn{1*J} vector or a \eqn{max(ncomp) * J} matrix 
encoding the L1 constraints applied to the outer weight vectors. The amount 
of sparsity varies between \eqn{1/sqrt(p_j)} and 1 (larger values of sparsity 
correspond to less penalization). If sparsity is a vector, L1-penalties are 
the same for all the weights corresponding to the same block but different 
components: 
\deqn{for all h, |a_{j,h}|_{L_1} \le c_1[j] \sqrt{p_j},}
with \eqn{p_j} the number of variables of \eqn{X_j}.
If sparsity is a matrix, each row \eqn{h} defines the constraints applied to 
the weights corresponding to components \eqn{h}:
\deqn{for all h, |a_{j,h}|_{L_1} \le c_1[h,j] \sqrt{p_j}.} It can be 
estimated by using \link{rgcca_permutation}.}

\item{init}{A character giving the mode of initialization to use in the algorithm. The alternatives are either by Singular Value Decompostion ("svd") or random ("random") (default: "svd").}

\item{bias}{A logical value for biaised (\eqn{1/n}) or unbiaised (\eqn{1/(n-1)}) estimator of the var/cov (default: bias = TRUE).}

\item{tol}{An integer giving the value for stopping the algorithm convergence.}

\item{response}{if not NULL, an integer giving the position of the response block within the blocks}

\item{superblock}{A boolean giving the presence (TRUE) / absence (FALSE) of
a superblock}

\item{method}{Either a character corresponding to the used method ("complete","knn","em","sem") or a function taking a list of J blocks (A) as only parameter and returning the imputed list. 
\itemize{
\item{\code{"mean"}}{ corresponds to an imputation by the colmeans}
\item{\code{"complete"}}{ corresponds to run RGCCA only on the complete subjects (subjects with missing data are removed)}
\item{\code{"nipals"}}{ corresponds to run RGCCA on all available data (NIPALS algorithm)}
\item{\code{"em"}}{ corresponds to impute the data with EM-type algorithms}
\item{\code{"sem"}}{ corresponds to impute the data with EM-type algorithms with superblock approach}
\item{\code{"knn1"}}{ corresponds to impute the data with the 1-Nearest Neighbor. 1 can be replace by another number (such as knn3) to impute with the 3-Nearest Neighbors.}}}

\item{rgcca_res}{A RGCCA object (see  \code{\link[RGCCA]{rgcca}})}

\item{parallelization}{A logical value to run a parallelization. 
If parallelization = NULL (default), the parallelization is always 
performed except for Windows if length(n_boot) < 10.}
}
\value{
\item{zstat}{The Z statistic is the difference, for each combination, 
between the non-permuted R/SGCCA criterion and the mean of the permuted 
R/SGCCA criteria divided by the standard deviation of the permuted R/SGCCA 
criteria.}

\item{bestpenalties}{Penalties giving the best Z-statistic for each 
blocks}

\item{permcrit}{A matrix of R/SGCCA criteria for each combination 
and each permutation}

\item{means}{Mean of the permutated R/SGCCA criteria for each 
combination}

\item{sds}{Standard deviation of the permutated R/SGCCA criteria for 
each combination}

\item{crit}{R/SGCCA criterion for each combination}

\item{pval}{The p-value is the fraction of the permuted R/SGCCA 
criteria, for each combination, that is greater than or equal to the 
non-permuted R/SGCCA criterion}

\item{penalties}{A matrix giving, for each blocks, the penalty 
combinations (tau or sparsity)}
}
\description{
This function can be used to automatically to select the hyper-parameters 
(amount of sparsity for sgcca and shrinkage parameters for RGCCA)
A permutation based strategy very similar to the one proposed in 
(Witten et al, 2009) is proposed.
}
\details{
The tuning parameters are selected using a permutation scheme. For each 
candidate tuning parameter value, the following is performed: 

(1) Repeat the following n_run times (for n_run large): \cr
   \verb{    }(a) The samples in \eqn{X_1},..., \eqn{X_J} are randomly 
   permuted blocks: \eqn{X_1^*},..., \eqn{X_J^*}. \cr
   \verb{    }(b) S/RGCCA is run on the permuted data sets \eqn{X_1^*},..., 
      \eqn{X_J^*} to get canonical variates \eqn{a_1^*},..., \eqn{a_J^*}.\cr
   \verb{    }(c) Record t* = sum_(j,k) c_jk g(Cov(X_j^*a_j^*, X_k^*w_k^*). 
      
(2) Sparse CCA is run on the blocks \eqn{X_1},..., \eqn{X_J} to obtain 
    canonical variates \eqn{a_1},..., \eqn{a_J}. 

(3) Record t = sum_(j,k) c_jk g(Cov(X_ja_j, X_kw_k). 

(4) The resulting p-value is given by $mean(t* > t)$; that is, the fraction 
of permuted totals that exceed the total on the real data. 
Then, choose the tuning parameter value that gives the smallest value in 
Step 4.

This function only selects tuning parameters for the first S/RGCCA block 
componentslevelfactors. By default, this function performs a one-dimensional 
search in tuning parameter space.
}
\examples{

####################################
# Permutation based strategy for   #
# determining the best shrinkage   # 
# parameters (tau)                 #
####################################

data("Russett")
blocks = list(agriculture = Russett[, seq(3)], 
              industry = Russett[, 4:5], 
              politic = Russett[, 6:11] )

# defaut value: it takes 10 sets between 0 
# and 1 for each block
fit = rgcca_permutation(blocks, par_type = "tau", 
                        n_run = 5, n_cores = 1)
                        
print(fit)
plot(fit)
fit$bestpenalties

# It is possible to define explicitly K combinations of shrinkage
# parameters to ne tested and in that case a matrix of dimension KxJ is 
required. Each row of this matrix corresponds to one specific set of 
shrinkage parameters. 

par_value = matrix(c(0, 0, 0, 
                     1, 1, 0,
                     0.5, 0.5, 0.5,
                     sapply(A, tau.estimate), 
                     1, 1, 1), 5, 3, byrow = TRUE)
                                                                 

fit <- rgcca_permutation(blocks, par_type = "tau", 
                         par_value = par_value, 
                         n_run = 5, n_cores = 1)

print(fit)
plot(fit)

####################################
# Permutation based strategy for   #
# determining the best sparsity    # 
# parameters                       #
####################################

# defaut value: it takes 10 sets between min values 
# 1/sqrt(ncol) and 1, for each block.

fit <- rgcca_permutation(blocks, par_type = "sparsity", 
                         n_run = 5, n_cores = 1)
                         
print(fit)
plot(fit)
fit$bestpenalties  

# when par_value is a vector of length J. Each element of the vector 
# indicates the maximum value of sparsity to be considered from 
# minimum values. par_length indicates the number of combinations 
# to be tested (defaut = 10)

fit <- rgcca_permutation(blocks, par_type = "sparsity", 
                         par_value = c(0.6, 0.75, 0.5), 
                         par_length = 7, n_run = 20, 
                         n_cores = 1)
                         
	print(fit)
	plot(fit)
	fit$bestpenalties
	
# when par_value is a scalar, the same maximum value is applied 
# for each block

fit <- rgcca_permutation(blocks, par_type = "sparsity", 
                          par_value = 0.8, par_length = 5, 
                          n_run = 10, n_cores = 1)
   
fit$penalties    

}
\references{
Witten, D. M., Tibshirani, R., & Hastie, T. (2009). A penalized 
matrix decomposition, with applications to sparse principal components and 
canonical correlation analysis. Biostatistics, 10(3), 515-534.
}
